암호학

@ 공개키 개인키로 전자서명하여 검증하는 과정
	*** 전자서명 -> 개인키 암호화
	서버에서 CA에 서버의 정보와 공개키를 보내며 인증요청을 한다 
	CA에서 검증을 거친후 서버의 정보와 공개키를 CA 개인키로 '암호화(전자서명)' 하여 인증서 제작 
		- 전자문서(원문)를 해쉬하여 문서 축약하고 그 값을 개인키로 암호화
	CA는 제작한 인증서 서버에 발급, 클라이언트(웹브라우저)에게 CA 공개키 제공 (브라우저에 내장됨)
	클라이언트가 SSL로 암호화된 페이지를 요청 
	서버는 서버의 공개키가 포함된 인증서를 전송해줌
	클라이언트가 자신이 신용있다가 판단한 CA서명이 있는지 확인
		- 전자서명된 부분이 클라이언트가 가지고 있는 CA 공개키로복호화해서 값이 같으면 신뢰할 수 있음 
			- 확인해야 할 정보인 메시지(전자문서 원문)의 해시를  구함 -> 개인키로 암호화된 메시지를 복호화해서 값이 같으면 검증됨 
	검증을 통해 얻은 서버의 정보와 공개키 획득 
	클라이언트는 서버의 공개키로 대칭키를 암호화하여 전송
	서버는 서버의 개인키로 대칭키를 복호화하여 획득 
		- 안전하게 전달된 대칭키를 이용하여 암호문을 주고 받음 
		-> 대칭키를 비대칭키로 암/복호화 하고,
		 	그 뒤로 데이터는 대칭키로 암/복호화



* CA 중심 인증서 설명
https://m.blog.naver.com/alice_k106/221468341565
* 인증서
https://curryyou.tistory.com/207

https://vitalholic.tistory.com/368
-----------


@ Aes 암호화 체인 모드 ( ecb cbc등) 암복호화 과정
	* AES
		- 표준 대칭키 알고리즘
		- 암호문을 생성(암호화)할 때 사용하는 키와 암호문으로부터 평문을 복원(복호화)할 때 사용하는 키가 동일한 암호 시스템 

		- 입력 평문의 길이는 128비트(16바이트)로 고정
		- AES의 기본 연산은 Byte 단위로 수행
		- 사용하는 암호화 키의 길이는 128, 192, 256 비트 중 하나를 선택할 수 있음
		- 알려진 모든 공격법에 대해 안전하도록 설계됨


	블록 단위 				- ECB, CBC, CTR
	스크림(비트) 단위  - CFB, OFB 

	* 블록 암호 운용 방식 
		- 암호학에서 블록 암호 운용 방식은 하나의 키에서 블록 암호를 반복적으로 안전하게 이용하는 절차
		- 특정한 길이의 블록 단위로 동작하기 때문에, 가변 길이 데이터를 암호화하기 위해서는 먼저 이들을 단위 블록들로 나누어야 하며, 그 블록들을 어떻게 암호화할지 정해야하는데, 이때 블록들의 암호화 방식을 '운용 방식'이라고 부른다. 

	* ECB 모드 (Electric CodeBook) 전자 부호표  모드
		- 평문 블록을 암호화한 것이 그대로 암호문 블록이 됨 
			- 동일한 내용을 갖는 평문 블록은 이에 대응되는 동일한 암호문 블록으로 변환되며 평문블록과 암호문블록이 일대잉 대응표를 갖게 된다. 
				- 모든 평문 블록이 각각 개별적으로 암호화되고, 복호화 때에는 개별적으로 복호화 됨 
			- 마지막 평문블록이 블록길이에 미치지 못할 경우에는 패딩(padding)이라는 적당한 길이의 비트열을 추가하여 블록의 길이에 맞도록 채워넣는다. 
		- 장점
			- 병렬 처리 가능
			- 오류 확산이 없다 (각 블록이 독립적으로 동작하기 때문)
		- 간단하지만 약점이 있어서 별로 사용되지 않음 
			- 가장 기밀성이 낮은 모드
			- ECB 모드에서는 평문 블록과 암호문 블록이 일대일의 관계를 유지하게 됨 
			- 암호문을 살펴보는 것만으로도 평문 속에 패턴의 반복이 있다는 것을 알게 됨 
				-> 이것을 실마리로 암호 해독을 할 수 있음 

	* CBC 모드 (Cipher Block Chaining mode)  암호블록 연쇄모드 , 암호 블록 체인 방식 
		- 암호문 블록을 마치 체인처럼 연결시키기 때문에 붙여진 이름 
		- 1개 앞의 암호문 블록과 평문 블록의 내용을 뒤섞은다음 암호화를 수행 
			- 이것으로 ECB 모드의 약점을 회피 
		- 1단계 전에 수행되어 결과로 출력된 암호문 블록에 평문 블록을 XOR하고 나서 암호화를 수행.
		- 생성되는 각각의 암호문 블록은 단지 현재 평문블록 뿐만 아니라 그 이전의 평문 블록들의 영향도 받게 됨 
		
		* 초기화 벡터 (Initalization Vector) : IV
			- 최초의 평문 블록을 암호화할 때 '1단계 앞의 암호문 블록'이 존재하지 않으므로
				'1단계 앞의 암호문 블록'을 대신할 비트열 블록 준비 
			- 암호화 때마다 다른 랜덤 비트열을 이용하는 것이 보통
			- 비밀키와 마찬가지로 송신자와 수신자간에 미리 약속되어 있어야 하지만 공개된 값을 사용해도 무방.
				- 비밀성보다 무결성이 중요
			- 제 2의 키 역할

			- 만약 서로 다른 2개의 메시지가 같은 평문, Key를 사용한다면 같은 암호문이 생성될 것이다.
				 이러한 경우가 많아진다면 공격자는 평문-암호문 관계를 통해서 쉽게 Key를 유추할 수 있을 것이다.
				 	-> 이 현상을 막기 위해 Iv를 사용.  다른 암호문이 나오도록 해줌 
				 		 같은 평문 같은 키를 사용하더라도 다른 암호문이 나오도록 해줌 (단, 매 암호화마다 다른 iv를 사용)

			- 복호화 진행시 IV를 알아야 하므로 암호화시 데이터 앞부분에 IV를 추가함 
				-> IV 사이즈만큼 데이터 용량이 증가되는 단점이 있음 

		* 패딩 (padding)
			- 실제 CBC 모드를 적용할 경우에 암호화될 평문의 길이는 가변적이기 때문
				- 마지막 블록이 블록의 길이와 항상 딱 맞아 떨어지지 않게 됨
				-> 부족한 길이만큼을 0으로 채우거나 임의의 비트들로 채워 넣음 


		- 암호화가 병렬처리가 아닌 순차적으로 수행 (암호화 입력 값이 이전 결과에 의존하기 때문)
			- 평문을 제대로 복호화하기 위해서는 암호문이 순서대로 배열되어 있어야한다. 
			- 복호화의 경우는 병렬화 가능(각 블록을 복호화한 다음 이전 암호화 블록과 XOR하여 복구할 수 있기 때문)
		- 깨진 암호문의 해당 블록과 다음 블록의 평문까지 영향을 미치게 됨


	* CFB 모드 (Cipher-FeedBack mode) 암호 피드백
		- 블록 암호를 기반으로 한 스트림 암호
		- CBC의 변형으로, 블록 암호를 자기 동기 스트림 암호로 변환 
		- 여기서 피드백이란 암호화의 입력으로 사용한다는 것의 의미
		- 패딩이 필요 없음, IV 사용 
		- 암호화 병렬처리 X 복호화 병렬처리 O


	* OFB 모드 (Output-FeedBack mode) 출력 피드백 
		- 블록 암호를 기반으로 한 스트림 암호
		- 평문 블록이 동일하면 암호문 블록이 같아지는 ECB 모드의 단점과
			오류 전파가 발생하는 CBC모드 CFB 모드를 개선한 동작 모드. 
		- 암호 알고리즘의 출력과 평문을 XOR하여 암호문 블록 생성 
			- 암호 알고리즘의 출력은 평문과 무관 
		- 전송 중의 비트 오류 전파되지 않음 
		- 암호문에서 비트 손실이 발생하면 
			그 다음에 오는 평문은 모두 에러가 발생하기 때문에 동기를 새로 맞추어야 한다. 
		- 암호문 송신자와 수신자 사이에 동기를 조절해야함 
			-> 전송 중인 암호문의 비트 손실이나 삽입 등에 유의 
		- IV가 바뀌면 암호문은 모두 바뀐다 
		- 패딩이 필요없음 , IV 사용 
		

	* CTR 모드 (CounTer mode) 카운터
		- 1씩 증가하는 카운터를 암호화해서 키 스트림을 생성해내는 스트림 암호 
			- 피드백(암호 알고리즘의 입력)으로 사용하지 않음
		- 패딩이 필요없음, IV 사용안함 
		- 암호화와 복호화가 같은 구조를 하고 있음
		- 비트 단위의 에러가 있는 암호문을 복호화하면 평문의 대응하는 비트만 에러가 됨 
		- 병렬 처리 가능 (이전 블록에 의존X)
















* CBC
https://jaebworld.tistory.com/10
*
http://www.parkjonghyuk.net/lecture/modernCrypto/lecturenote/chap04.pdf

https://m.blog.naver.com/PostView.nhn?blogId=kookh1&logNo=120188816752&proxyReferer=https:%2F%2Fwww.google.com%2F
