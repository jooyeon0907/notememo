
@ HTTP (Hyper Text Transfer Protocol)
	- 인터넷에서 데이터를 주고받을 수 있는 응용 계층 프로토콜 (80번 포트) 
		-> 서버와 클라이언트 간의 통신을 하기 위한 통신 규약.
	- 웹에서만 사용하는 프로토콜로 TCP/IP 기반으로 서버와 클라이언트의 요청과 응답을 전송한다. 

	- 정보를 평문(하이퍼 텍스트 문서)으로 주고 받아 누구든 알아볼 수 있는 형식으로 보내지기 때문에
		오가는 정보를 중간에서 탈취당할 위험이 큼 -> HTTPS로 보안 
	
	- World Wide Web에서 이미지, 비디오, 텍스트 HTML 파일 및 쿼리 결과의 형태로 데이터를 전송하기 위해 배포됨.
	- 할당 된 기본 포트는 80번 이지만, 다른 포트도 적용 할 수 잇음
		-> 기본적으로 서로 통신하기 위해 인터넷의 다양한 기계 간의 통신 표준화

	- 음성, 텍스트 또는 비디오와 같은 모든 형태의 데이터를 전송할 수 있음
		-> 클라이언트와 서버가 각자의 끝에서 분석 부분을 처리하기 때문


@ HTTP 동작 과정
	- 클라이언트 : 브라우저 (Internet Explorer, Chrome, Firefox) 
	  서버 : 웹 서버, 웹 어플리케이션 ( 톰캣, nginx, gws, 아파치 HTTP 서버...)

	1. 사용자가 웹 브라우저에 URL 주소 입력
	2. DNS 서버에 웹 서버의 호스트 이름을 IP 주소로 변경 요청함
	3. 웹 서버와 TCP 연결 시도
		* 3 way handshake : 클라이언트 - 서버 간 신뢰성 있는 연결을 하기 위해 3번의 패킷 교환 과정
	4. 서버에게 GET 명령을 전송
	5. 서버가 클라이언트에게 데이터(웹 문서)를 회신한다.
	6. 서버 - 클라이언트 간 연결 해제
		* 4 way handshake : 서버와 클라이언트 양쪽 다 연결을 종료시킨다는 메시지를 보냄 (양쪽 다 각각이므로 4번의 패킷 교환 과정이 일어남)	
	7. 웹 브라우저가 웹 문서를 출력한다

	- HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜
		-> 이러한 단점을 해결하기 위해 Cookie와 Seesion 등장
	- HTTP는 연결을 유지하지 않는 프로토콜이기 때문에
		요청/응답(request/response) 방식으로 동작 

* 동작 과정 자세한 내용
https://jess-m.tistory.com/17

* 쿠키 세션 차이
https://hahahoho5915.tistory.com/32

* Http 통신과 Socket 통신 
https://hees-dev.tistory.com/53?category=864258


@ HTTP 메시지
	- 시작줄(start line), 헤더(headers), 본문(body)으로 구성 
	- 헤더는 Key:Value로 되어있음 

	* 요청(Request) 메시지 구조
		[요청문]
			- 요청메소드 (GET, POST, PUT ..)
			- 요청 URL
			- HTTP 버전
		[헤더]
			- request 헤더 (Host, User-Agent, Accept..)
			- general 헤더 (Date, Connection ..)
			- entity  헤더 (Content-Type ... )
		[공백]
			- 메타 데이터 전송이 끝났음을 알리는 공백
		[바디]
			- 서버에 전송하는 데이터 등
		
		ex)
		GET https://www.zerocho.com HTTP/1.1   ## 요청문
		User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...   ## 헤더 : 요청에 대한 정보를 담고 있음. 
		Upgrade-Insecure-Requests: 1
		
		(본문 없음)								## 헤더에서 한 줄 띄고 본문 시작. 요청을 할 때 함께 보낼 데이터를 담는 부분. 

	*응답(response) 메시지 구조
		[상태문]
			- HTTP 버전
			- 상태코드 (200, 404..)
			- 상태이름 (OK, Not Found ...)
		[헤더]
			- response 헤더 (Server, Set-Cookie, Age .. )
			- general 헤더 (Date, Connection ..)
			- entity  헤더 (Content-Type ... )
		[공백]
			- 메타 데이터 전송이 끝났음을 알리는 공백
		[바디]	
			- 클라이언트에 전송하는 데이터 등

		ex)
		HTTP/1.1 200 OK 		# 첫 줄은 버전 상태코드 상태메시지 (200은 성공적인 요청)
		Connection: keep-alive   # 두 번째 줄부터는 헤더 시작 : 웅답에 대한 정보를 담고 있음 
		Content-Encoding: gzip
		Content-Length: 35653
		Content-Type: text/html;  # 헤더 끝
	
		<!DOCTYPE html><html lang="ko" data-reactroot=""><head><title... 	# 본문 : 요청한 데이터를 담음 

		** keep-alive
			- HTTP/1.1 스펙부터 keep-alive 헤더가 추가되어 커넥션을 맺은체로 사용할 수 있다. 


	*** curl 로 확인할 수 있음 -> http 를 이용하여 경로의 데이터를 가져옴 
	@ curl
	curl -v 기타 옵션 : 디버깅을 위해 요청과 응답 헤더까지 모두 표시
	curl http://www.xxx.com : 일반 GET 요청 
				명령어를 실행하면 URL 요청을 통해, HTML 문서 형태로 응답 받은 것을 확인할 수 있음.
	-I : 헤더만 가져오기 
	-i : 헤더와 바디까지 가져오기
	
	'>' : 요청
	'<' : 응답


* http 메시지 구조
	 https://velog.io/@teddybearjung/HTTP-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-%ED%95%B5%EC%8B%AC-%EC%9A%94%EC%86%8C

* HTTP 메소드
	https://m.blog.naver.com/PostView.nhn?blogId=2000sky2&logNo=220619302087&proxyReferer=https:%2F%2Fwww.google.com%2F




* http란
	https://hees-dev.tistory.com/42
	https://noahlogs.tistory.com/34?category=827412